from gpt import GPT
from gpt.tools import full_path
from gpt.gpt import run_gpt

from distgen import Generator   
from distgen.writers import write_gpt
from distgen.tools import update_nested_dict

from gpt.gpt_phasing import gpt_phasing

import yaml
import os

def set_gpt_and_distgen(gpt, distgen_input, settings, verbose=False):
    """
    Searches gpt and distgen input for keys in settings, and sets their values to the appropriate input.
    """
    for k, v in settings.items():
        found=gpt.set_variable(k,v)
        #print(k,v,found)
        if verbose and found:
            print(k, 'is in gpt')
        
        if not found:
            distgen_input = update_nested_dict(distgen_input, {k:v}, verbose=verbose)
            #set_nested_dict(distgen_input, k, v)    
    
    return gpt, distgen_input
    
def run_gpt_with_distgen(settings=None,
                         gpt_input_file=None,
                         distgen_input_file=None,
                         workdir=None, 
                         use_tempdir=True,
                         gpt_bin='$GPT_BIN',
                         timeout=2500,
                         auto_phase=False,
                         verbose=False,
                         asci2gdf_bin='$ASCI2GDF_BIN'
                         ):
    """
    Run gpt with particles generated by distgen. 
    
        settings: dict with keys that can appear in an gpt or distgen Generator input file. 
        
    Example usage:
        G = run_gpt_with_distgen({'lspch':False},
                       gpt_input_file='$LCLS_LATTICE/gpt/models/gunb_eic/gpt.in',
                       distgen_input_file='$LCLS_LATTICE/distgen/models/gunb_gaussian/gunb_gaussian.json',
                       verbose=True,
                       timeout=None
                      )        
        
    """

    # Call simpler evaluation if there is no generator:
    if not distgen_input_file:
        return run_gpt(settings=settings, 
                       gpt_input_file=gpt_input_file, 
                       workdir=workdir,
                       use_tempdir=use_tempdir,
                       gpt_bin=gpt_bin, 
                       timeout=timeout, 
                       verbose=verbose)
        
    
    if verbose:
        print('run_gpt_with_distgen') 

    # Make gpt and generator objects
    G = GPT(gpt_bin=gpt_bin, input_file=gpt_input_file, workdir=workdir, use_tempdir=use_tempdir)
    G.timeout=timeout
    G.verbose = verbose

    # Distgen generator
    gen = Generator(verbose=verbose)
    f = full_path(distgen_input_file)
    distgen_params = yaml.safe_load(open(f))

    # Set inputs
    if settings:
        G, distgen_params = set_gpt_and_distgen(G, distgen_params, settings, verbose=verbose)
    
    # Link particle files
    particle_file = os.join(G.path , os.path.basename(G.get_dist_file()))
    
    

    if(verbose):
        print('Linking particle files, distgen output -> "'+particle_file+'".')

    if('output' in distgen_params and verbose):
        print('Replacing Distgen output params')

    distgen_params['output'] = {'type':'gpt','file':particle_file}

    if(verbose):
        print('\nDistgen >------')
    # Configure distgen
    gen.parse_input(distgen_params)       

    # Run
    beam = gen.beam()
    particle_file = os.path.join(G.path, particle_file)
    write_gpt(beam, particle_file, verbose=verbose, asci2gdf_bin=asci2gdf_bin)
    
    if(verbose):
        print('------< Distgen\n')

    if(auto_phase): 
        if(verbose):
            print('\nAuto Phasing >------')

        G.write_input_file()   # Write the unphased input file
        phased_file_name, phased_settings = gpt_phasing(G.input_file, path_to_gpt_bin=G.gpt_bin[:-3], verbose=verbose)
        G.set_variables(phased_settings)

        if(verbose):
            print('------< Auto Phasing\n')

    G.run()
    
    return G


def evaluate_gpt_with_distgen(settings, archive_path=None, merit_f=None, **run_gpt_with_distgen_params):
    """
    Simple evaluate GPT.
    
    Similar to run_astra_with_distgen, but returns a flat dict of outputs. 
    
    Will raise an exception if there is an error. 
    
    """
    G = run_gpt_with_distgen(settings, **run_gpt_with_distgen_params)
        
    if merit_f:
        output = merit_f(G)
    else:
        output = default_gpt_merit(G)
    
    if output['error']:
        raise
    
    fingerprint = G.fingerprint()
    
    output['fingerprint'] = fingerprint
    
    if archive_path:
        path = full_path(archive_path)
        assert os.path.exists(path), f'archive path does not exist: {path}'
        archive_file = os.path.join(path, fingerprint+'.h5')
        G.archive(archive_file)
        output['archive'] = archive_file
        
    return output


